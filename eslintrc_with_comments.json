{
    "parser": "babel-eslint",
    "env": {
        "browser": true,
        "node": true,
        "es6": true
    },
    "extends": [
        "eslint:recommended",
        "plugin:flowtype/recommended"
    ],
    "plugins": [
        "flowtype"
    ],
    "rules": {
        // Overite eslint:recommended
        //
        // Never assume users will not press `F12`.
        "no-console": "off",
        // ES6 brings in block level function declaration.
        "no-inner-declarations": "off",
        //
        // Customization
        //
        // Enfores curly braces after `if` statements etc.
        "curly": ["error", "all"],
        // Enfores `===` and `!==`.
        "eqeqeq": "error",
        // Since we have the above `eqeqeq` rule, we do not need yoda experssion,
        // which reduces readability.
        // However, `0 < x && x < 1` is actually more readable.
        "yoda": ["error", "never", { "exceptRange": true }],
        // Test `{}.hasOwnProperty.call(obj, key)`
        // to prevent including properties that are inherited through the prototype chain.
        "guard-for-in": "error",
        // Lexical declaration is visible in the entire switch block
        // but it only gets initialized when the case where it is defined is reached.
        "no-case-declarations": "error",
        // Use `bind()` when there is actualy `this` in function body.
        "no-extra-bind": "error",
        // Always use `0.6` instead of `.6`.
        "no-floating-decimal": "error",
        // Avoid modifying built-in global variables.
        "no-global-assign": "error",
        // Things like `"" + 1` is too  clear to me.
        "no-implicit-coercion": "error",
        // `setTimeout()` and `setInterval()` can accept a string of JavaScript code as their first argument.
        "no-implied-eval": "error",
        // Yet another `eval` like.
        "no-script-url": "error",
        // This SpiderMonkey extension is obsolete.
        // Use ES6's iterator and generator instead.
        "no-iterator": "error",
        // For typos.
        "no-multi-spaces": "error",
        // `new Boolean(...)`, `new Number(...)`, and `new String(...)` are rarely used.
        // And it is confusing that `new Boolean(false)` resolves to `true`.
        "no-new-wrappers": "error",
        // Similarly, no `new Symbol(...)`.
        "no-new-symbol": "error",
        // Disallow using `new C();` for side effects only.
        "no-new": "error",
        // Deprecated in ES5.
        "no-octal-escape": "error",
        // Swift forbids this.
        "no-param-reassign": "error",
        // `__proto__` is deprecated in ES3.1. Use `getPrototypeOf` instead.
        "no-proto": "error",
        // To avoid typos, similar to `if (a = b)`.
        "no-return-assign": "error",
        // `return await` is useless in `async` functions.
        "no-return-await": "error",
        // Most likely a typo.
        "no-self-compare": "error",
        // Comma operator frequently obscures side effects, and is often an accident.
        "no-sequences": "error",
        // Throw `Error` objects, not strings.
        "no-throw-literal": "error",
        // Probably a mistake.
        "no-unmodified-loop-condition": "error",
        // IDEs will probably warn against this.
        "no-unused-expressions": "error",
        // Flag usage of Function.prototype.call() and Function.prototype.apply()
        // that can be replaced with the normal function invocation,
        // to speed up programs.
        "no-useless-call": "error",
        // Disallow unnecessary concatenation of strings.
        "no-useless-concat": "error",
        // Escaping non-special characters in strings, template literals, and regular expressions doesn’t have any effect.
        "no-useless-escape": "error",
        // Disallow use of the void operator.
        // `void expression` evaluate `expression` and return `undefined`.
        // Common usage cases of `void`:
        // - Workaround of `undefined` variable is mutable piror to ES5. Now ES5 is widely supported.
        // - Because of `void 0` shorter than `undefined`. If this did matter, this is the job of a minifier.
        // - In IIFE(immediately-invoked function expression), `void function(){ foo = 1; }()`
        //   forces the function to be treated as expression instead of declaration.
        //   We prefer `(function(){ foo = 1; }())`, which is cleaner.
        "no-void": "error",
        // To prevent typos.
        "wrap-iife": "error",
        // Disallow `async` functions which have no `await` expression.
        "require-await": "error",
        // While ES5 disallows overriting `undefined`, it is still possible to shadow `undefined`.
        // Thus we forbid the use of `undefined`:
        // - Variables that should be `undefined` are simply left uninitialized.
        // - Checking if a value is `undefined` should be done with `typeof`.
        //
        // Also, `undefined` is a hole in source code.
        // `var a = X` is a definition declaration unless `X` is `undefined`.
        "no-undefined": "error",
        // Use `path.join` since it works across OSes with different path seperators.
        "no-path-concat": "error",
        // Prevent forgetting to handle the first `error` argument.
        "handle-callback-err": ["error", "^(err|error|\\w+Error)$"],
        // It’s unnecessary to use computed properties with literals.
        "no-useless-computed-key": "error",
        // ES2015 provides a default class constructor if one is not specified.
        // As such, it is unnecessary to provide an empty constructor or one that simply delegates into its parent class.
        "no-useless-constructor": "error",
        // Disallow renaming import, export, and destructured assignments to the same name.
        "no-useless-rename": "error",
        // Forbid `var`. Use block scoped `let` and `const` instead.
        "no-var": "error",
        // If a variable is never reassigned, suggest `const`.
        "prefer-const": "error",
        // Prefer the rest parameter in ES2015, instead of `arguments`, which does not have methods of `Array.prototype`.
        "prefer-rest-params": "error",
        // Disallow generator functions that do not have `yield` to avoid typos.
        "require-yield": "error",
        // Prefer arrow functions as callbacks since `this` in them bind to the upper scope's.
        "prefer-arrow-callback": "error",
        // Disallow duplicate keys in object literals.
        "no-dupe-keys": "error",
        // "use strict"
        "strict": ["error", "global"],
        //
        // Styling
        //
        "array-bracket-spacing": "error",
        "arrow-body-style": "error",
        // Lambdas in a lot of languages requires parens.
        // We think they do has reasons.
        // Although when the right hand is an expression, omitting parens at the left hand appears balanced,
        // they have total different semantics.
        // The left hand of the fat arrow is a parameter list,
        // and the right hand of the fat arrow is an expression.
        // Similarly, the right hand can be a group of statements,
        // which uses `{}`, distinguished with a right hand of expression.
        "arrow-parens": ["error", "always"],
        "block-spacing": "error",
        // FIXME: rational coding-style
        "brace-style": ["error", "allman"],
        "capitalized-comments": [
            "error",
            "always",
            {
                "ignoreInlineComments": true
            }
        ],
        "comma-spacing": "error",
        "comma-style": "error",
        "computed-property-spacing": "error",
        "eol-last": "error",
        // Considering the spacing of generators:
        //
        // 1. `function* a_generator() {}`
        // 2. `function *a_generator() {}`
        // 3. `function * a_generator() {}`
        // 4. `function*a_generator() {}`
        //
        // First we drop **4** for the same reson we dropped infix operators without spacing
        // (actually it is less readable with that.
        // Then we drop **3** because it is similar to multiple operation.

        // Both **1** and **2** are acceptable to us.
        // `function*` reads as "We are declareing a special kind of function."
        // `*a_generator` reads as "`a_generator` is a special kind of function, let's prefix its name with `*`,
        // just like some style prefixes private memeber with `_`."
        // However, `_private_function` is invoked as `_private_function()`,
        // but `function *a_generator()` is invoked as `a_generator()`.
        //
        // Then let's look at function expression:
        //
        // `1. function* () {}`
        // `2. function *() {}`
        //
        // We feel **1** is better, since `()` is seledomly prefixed with an operator or symbol,
        // making `*()` looks unusual.
        // Another issue with `*() {}` is since `*()` is grouped together,
        // it seems saying that `*` is only a mark of the parameter list of function,
        // not the whole function.
        //
        // But consider shorthand functions:
        //
        // 1. `*a_generator() {}`
        // 2. `* a_generator() {}`
        //
        // This time we dislike **2**, because `*` feels lonely
        // and it actually looks similar with `function * "a_generator()`.
        //
        // Also consider alignment:
        //
        // ```js
        // {
        //     a: 1,
        //     b: 2,
        //     c() { return 3; },
        //     *d() { return 4; }
        // }
        // ```
        //
        // v.s.
        //
        // ```js
        // {
        //     a: 1,
        //     b: 2,
        //     c() { return 3; },
        //     * d() { return 4; }
        // }
        // ```
        //
        // Thus we prefer `function* a_generator() {}` and `function* () {}`
        // but `*a_generator() {}`.
        // Afterall, `* a_generator() {}` is not consistent with `function* a_generator()` either,
        // since we choose `function*` for mark `function` with `*`, not seperate `*` and `a_generator`.
        //
        // FIXME
        // https://github.com/eslint/eslint/issues/6195
        //
        // Same applies to yield star (delegation)
        "yield-star-spacing": ["error", "after"],
        "indent": [
            "error",
            4,
            {
                "FunctionExpression": {
                    "parameters": "first"
                },
                "CallExpression": {
                    "arguments": "first"
                }
            }
        ],
        "key-spacing": "error",
        "keyword-spacing": "error",
        "linebreak-style": "error",
        "lines-around-comment": "error",
        "new-cap": "error",
        "no-continue": "error",
        // JavaScript allows the omission of parentheses when invoking a function via the new keyword and the constructor has no comment,
        // which in inconsistent.
        "new-parens": "error",
        "no-duplicate-imports": "error",
        "no-mixed-spaces-and-tabs": "error",
        "no-multiple-empty-lines": [
            "error",
            {
                "max": 2,
                "maxBOF": 1
            }
        ],
        "no-negated-condition": "error",
        "no-nested-ternary": "error",
        // Prefer the concise literal syntax `{}` over `new Object()`.
        "no-new-object": "error",
        "no-trailing-spaces": "error",
        "no-unneeded-ternary": "error",
        "no-whitespace-before-property": "error",
        // Also applies to `let` and `const`.
        "one-var": ["error", "never"],
        "operator-linebreak": "error",
        // Properties shorthand like `letters = {a, b, c}` is not commonly used.
        // And inconsistent shorthand like `{0, 1: "one" }` is less readable.
        // Thus we choose `consisten-as-needed`.
        // Method shorthand like `b() { return 6; }` is consice and clear.
        // Ceylon (`Integer b { return 6; }`) and Swift (`var b: Int { return 6; }")`
        // have a similar syntax for class getters or computed property.
        "object-shorthand": ["error", "consistent-as-needed"],
        // Disallow parseInt() with a radix of 2 (binary), 8 (octal), and (16) hexadecimal.
        "prefer-numeric-literals": "error",
        // Instead of `.apply()`.
        "prefer-spread": "error",
        // Reasons for double quotes:
        // - JSON uses double quoted strings: so you never type the trailing comma in JavaScript literal object?
        // - A lot of languages use single quotes for character.
        //   Using double string so you do not need to remember the difference.
        //   But you need to know that there is no `char` type in JavaScript.
        //   From that you can conclued that single quotes is probably also used for strings.
        //   And you need to remember backtick for string templates anyway.
        //
        // Reason for single quotes: easier to type.
        //
        // For the same reason, enable `avoidEscape` to avoid typing `\`.
        "quotes": [
            "error",
            "single",
            {
                "avoidEscape": true,
                "allowTemplateLiterals": false
            }
        ],
        // Both are useful. Quoted as dictionries keys, and unquoted for properties.
        "quote-props": ["error", "consistent"],
        "rest-spread-spacing": "error",
        // Rational: FIXME github/weakish/coding-style
        "semi": ["error", "never"],
        "semi-spacing": "error",
        "space-before-blocks": "error",
        "space-before-function-paren": [
            "error",
            {
                "anonymous": "always",
                "named": "never",
                "asyncArrow": "always"
            }
        ],
        "space-in-parens": "error",
        "space-infix-ops": "error",
        "space-unary-ops": [
            "error",
            {
                "words": true,
                "nonwords": false
            }
        ],
        "symbol-description": "error",
        "template-curly-spacing": "error",
        "unicode-bom": "error"
    }
}
