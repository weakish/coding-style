Ruby Coding Style
=================

## Test against true/false.

Condition tests should accept a boolean value.
So we do not need to remember which values are considered true or false.
For example, in Ruby only `false` and `nil` is false, but in Python, `''`, `0`, `()`, `[]`, and `{}` are also `false`.

Prefer

```ruby
if not a.nil?
  # do something
end
```

over

```ruby
if a
  # do something
end
```

## No Yoda Notation

In C, we can use `if (1 == a) ...` instead of `if (a == 1) ...` to avoid the possible mistake of `if (a = 1) ...`.

On Ruby we does not need this.

Though In Ruby `a = 1` still returns `1` (it should return nil) and `if` still accept non bool values, Ruby actually will warn you if it find `=` in conditional test:

```
warning: found = in conditional, should be ==
```

## Prefer `if then else` than `if then return`

Preferred:

```ruby
if condition
  x
else
  y
end
```

Not preferred:

```ruby
if condition
  return x
end
y
```

For the latter, in a long function, when reading something in y, you will not realized that the function may already return x and y will not be executed at all.


## Prefer `f()` for non `void` functions, and `f` for actions/side effects.

```ruby
# @param number [Fixnum]
# @return character [String]
def f(n)
  n
end

# @return character [String]
def f_1()
  f(1)
end

# @param number [Fixnum]
# @return [void] prints to screen
def print_number n
  puts n
end

# @return [void] prints to screen
def print_1
  print_number 1
end
```

## Use `{}` for blocks rerunning value, and `do end` for other blocks.

```ruby
l = [1, 2, 3]

l.each do |n| n += 1 end

l.map { |n|
  b = (n + 1) * (n + 2) / 3.0
  b.to_s
}

identity = ->(x) { x }
say = ->(x) do puts x end
```

## Avoid `Proc.new` and `proc`.

Avoid `Proc.new`.

Never use `proc`. Its behavior is different for Ruby 1.8 and Ruby 1.9+.

## Use `self` module functions.

Prefer

```ruby
mod M
  def self.a; 'a'; end
  def self.b; 'b'; end
  # more ...
end

M.a()
```

over

```ruby
module M
  # module_function will copy the functions. No need to make duplicated
  # functions unless you want to let other classes include your module
  # and let them pollute other classes' namespcae.
  module_function

  def a; 'a'; end
  def b; 'b'; end
  # more ...
end

M.a()
```

over

```ruby
class C
  # Do not build a class just for some functions. Use module for this.
  class << self

    def a; 'a'; end
    def b; 'b'; end
    # more ...
  end
end

C.a()
```

and

```ruby
class C
  def a; 'a'; end
  def b; 'b'; end
  # more ...
end

# This is redundant.
c = C.new()
c.a()
```

-----

The following rules are borrowed from [scheme-style](http://community.schemewiki.org/?scheme-style).

Since scheme uses a lot of parens and Ruby do not, so we apply this rule:

If in equivalent scheme code, there will be a paren, then indent two spaces.
Otherwise indent one spaces.

For example:

```lisp
(1
 2
 3)
```

```ruby
[1,
 2,
 3]
```
