Coding Style for Python
=======================

Styles stolen from Google
-------------------------

[Google python style](http://google-styleguide.googlecode.com/svn/trunk/pyguide.html)

### Main

Even a file meant to be used as a script should be importable and a mere
import should not have the side effect of executing the script's main
functionality. The main functionality should be in a main() function.

In Python, pychecker, pydoc, and unit tests require modules to be importable.
Your code should always check if __name__ == '__main__' before executing
your main program so that the main program is not executed when the module
is imported.


Personal
--------

### Variable naming

* Don't use camlCase as compound_variable names.  CamlCase is somewhat less
  readable, especially when the name includes acronyms or initialisms, e.g.
  `getACCVSURL` v.s. `get_a_C_CVS_URL`.  And you shouldn't need CamlCase to
  shorten line length.  Also, `aVeryLongCamlCaseVariableName` is not_readable_at_all.

* The only exception of the above rule is `ClassName`, because:

    - Python itself already uses this style, e.g. `TypeError`.
    - Class names usually begins with a capital.
    - Class names are usually not long.

    Also, for a variable referring to an instance of `ClassName`, we may use `className`,
    so we can know its class/type from its name.

* Use a `var_` prefix for `var_reassignable_variable`.

### Functions

* Use pure functions when possible.
* Prefer small functions.
* Isolate side-effects.

### Modules

* Use '_' prefixed names instead of ``__all__`` list.  This is simple and
  straight up, and doesn't require the additional effort to maintain an
  extra list.

### Tests

Most of the time I just use doctest,
since it's easy to maintain consistency of code, test and documentation.

### Classes

Do not abuse `class`.
We already have closures to conveniently implemented higher-order functions, and modules.

### Use `pass` to end a block.

Consider the following Python code:

```python
def f():
    for i in range(10):
        i = i * 2
        print(i)
```

With one wrong keystroke (`TAB`):

```python
def f():
    for i in range(10):
        i = i * 2
    print(i)
```

The above code is also valid.

To avoid this kind of mistakes, we can use `pass` for `end` in Python:

```python
def f():
    for i in range(10):
        i = i * 2
        print(i)
        pass
```

With one wrong keystroke (`TAB`):

```python
def f():
    for i in range(10):
        i = i * 2
    print(i)
        pass
```

Python will refuse to work:

```python
IndentationError: unexpected indent
```

However, python will not always catch unintended indentation even with `pass`.

Suppose we intend to write:

```python
def g():
    for i in range(10):
        i = i * 2
        pass
    print(i)
```

With one wrong keystroke (`TAB`):

```python
def g():
    for i in range(10):
        i = i * 2
        pass
        print(i)
```

Python will *not* refuse to work.

But using `pass` still has two advantages:

- It still provides visual hint.

    If you think `pass` as the last clause of an indented block,
    `print(i)` looks wired to you in the above code.

- A decent editor/IDE will indent correctly if you typed `pass`.

You can omit `pass` when unambiguous:

```python
try:
    print("some code")
except:
    try:
        print("some code")
    finally:
        print("some code")
```

`finally` is not possible to belong to the outer try.
        
Sometimes it is ambiguous if an `eles` belongs to `if-eles` or `try-except-else`,
but if we write `eles` for every `if` clauses, we can omit more `pass`.
